# %%
# %% [markdown]
# # Visualize Full SDE Trajectories
#
# This notebook visualizes full SDE trajectories generated by `generate_full_trajectories.py`.
#
# Unlike the knot-only visualization in `fae_latent_msbm_latent_viz.py`, this shows
# **all intermediate SDE steps** between marginal time points.

# %%
from __future__ import annotations

import sys
from dataclasses import dataclass
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
from matplotlib import cm
from matplotlib.collections import LineCollection
from matplotlib.lines import Line2D

# Make repo importable
path_root = Path(__file__).resolve().parent.parent
print(f"Adding repo root to sys.path: {path_root}")
if str(path_root) not in sys.path:
    sys.path.insert(0, str(path_root))

from scripts.images.field_visualization import format_for_paper

print("Imports successful!")

# %%
format_for_paper()

# %% [markdown]
# ## Configuration

# %%
# Path to the .npz file generated by generate_full_trajectories.py
traj_path = Path("/data1/jy384/research/MMSFM/results/fae_latent_msbm_var0625/full_trajectories.npz")

# Visualization settings
n_traj_plot = 10  # How many trajectories to show
embed_method = "pca"  # {"pca", "identity"} - only use identity if latent_dim <= embed_dim
embed_dim = 2  # 2 or 3

# Background manifold settings (matches `fae_latent_msbm_latent_viz.py`)
manifold_split = "test"  # {"train","test"}
points_per_time = 800

# Plot toggles
overlay_knots = True

# PCA settings (if latent_dim > embed_dim)
max_fit_points = 20000
seed = 42

viz_dir = traj_path.parent / "full_traj_viz"
viz_dir.mkdir(parents=True, exist_ok=True)
print(f"Saving figures to: {viz_dir}")

# %%
if not traj_path.exists():
    raise FileNotFoundError(
        f"Trajectory file not found: {traj_path}\n"
        "Run scripts/fae/generate_full_trajectories.py first."
    )

npz = np.load(traj_path, allow_pickle=True)

# Load what's available
zt = np.asarray(npz["zt"], dtype=np.float32) if "zt" in npz else None
latent_f_full = np.asarray(npz["latent_forward_full"], dtype=np.float32) if "latent_forward_full" in npz else None
latent_b_full = np.asarray(npz["latent_backward_full"], dtype=np.float32) if "latent_backward_full" in npz else None
latent_f_knots = np.asarray(npz["latent_forward_knots"], dtype=np.float32) if "latent_forward_knots" in npz else None
latent_b_knots = np.asarray(npz["latent_backward_knots"], dtype=np.float32) if "latent_backward_knots" in npz else None

npz.close()

print("Loaded trajectories:")
if latent_f_full is not None:
    print(f"  Forward (full): {latent_f_full.shape} (T_steps, N, K)")
if latent_b_full is not None:
    print(f"  Backward (full): {latent_b_full.shape} (T_steps, N, K)")
if latent_f_knots is not None:
    print(f"  Forward (knots): {latent_f_knots.shape} (T_marginals, N, K)")
if latent_b_knots is not None:
    print(f"  Backward (knots): {latent_b_knots.shape} (T_marginals, N, K)")

# Infer dimensions
if latent_f_full is not None:
    latent_dim = latent_f_full.shape[-1]
elif latent_b_full is not None:
    latent_dim = latent_b_full.shape[-1]
else:
    raise ValueError("No full trajectories found in the file.")

print(f"\nLatent dimension: {latent_dim}")

# %% [markdown]
# ## Load latent marginals (manifold background)
#
# `generate_full_trajectories.py` writes trajectories only; to match the manifold-style plots in
# `fae_latent_msbm_latent_viz.py`, we also load `fae_latents.npz` from the same run directory.

# %%
run_dir = traj_path.parent
latents_path = run_dir / "fae_latents.npz"

latent_train = None
latent_test = None

if latents_path.exists():
    lat_npz = np.load(latents_path, allow_pickle=True)
    latent_train = np.asarray(lat_npz["latent_train"], dtype=np.float32) if "latent_train" in lat_npz else None
    latent_test = np.asarray(lat_npz["latent_test"], dtype=np.float32) if "latent_test" in lat_npz else None
    if zt is None and "zt" in lat_npz:
        zt = np.asarray(lat_npz["zt"], dtype=np.float32)
    lat_npz.close()

    if latent_train is None or latent_test is None:
        print(f"Warning: {latents_path} missing latent_train/latent_test; manifold background disabled.")
        latent_train, latent_test = None, None
else:
    print(f"Warning: missing {latents_path}; manifold background disabled.")

if zt is None:
    raise ValueError("Missing `zt` in trajectories and could not load it from fae_latents.npz.")

# %% [markdown]
# ## PCA embedding (matches `fae_latent_msbm_latent_viz.py`)

# %%
@dataclass
class LinearEmbedding:
    mean: np.ndarray  # (K,)
    components: np.ndarray  # (D, K)

    def transform(self, x: np.ndarray) -> np.ndarray:
        x2 = x.reshape(-1, x.shape[-1]).astype(np.float32, copy=False)
        y = (x2 - self.mean[None, :]) @ self.components.T
        return y.reshape(*x.shape[:-1], self.components.shape[0])


def _fit_pca_embedding(
    latents: np.ndarray,  # (T,N,K)
    *,
    dim: int,
    max_points: int,
    seed: int,
    extra: np.ndarray | None = None,
) -> LinearEmbedding:
    rng = np.random.default_rng(int(seed))
    T, N, K = latents.shape

    x = latents.reshape(T * N, K)
    take = min(int(max_points), x.shape[0])
    idx = rng.choice(x.shape[0], size=take, replace=False)
    fit = x[idx]
    if extra is not None:
        fit = np.concatenate([fit, extra.reshape(-1, K)], axis=0)

    try:
        from sklearn.decomposition import PCA

        pca = PCA(n_components=int(dim), random_state=int(seed))
        pca.fit(fit)
        explained = getattr(pca, "explained_variance_ratio_", None)
        if explained is not None:
            print(f"PCA explained variance ratio: {np.round(explained, 4).tolist()}")
        return LinearEmbedding(
            mean=pca.mean_.astype(np.float32),
            components=pca.components_.astype(np.float32),
        )
    except Exception:
        # Numpy fallback
        fit = fit.astype(np.float32, copy=False)
        mean = fit.mean(axis=0)
        x0 = fit - mean[None, :]
        _, _, vt = np.linalg.svd(x0, full_matrices=False)
        comps = vt[: int(dim)].astype(np.float32, copy=False)
        return LinearEmbedding(mean=mean.astype(np.float32), components=comps)


def _subsample_per_time(latents: np.ndarray, n: int, seed: int) -> np.ndarray:
    rng = np.random.default_rng(int(seed))
    T, N, _K = latents.shape
    n_use = min(int(n), int(N))
    out = []
    for t in range(T):
        idx = rng.choice(N, size=n_use, replace=False)
        out.append(latents[t, idx])
    return np.stack(out, axis=0)


embed_dim_eff = min(embed_dim, latent_dim)

latent_for_manifold = None
if latent_train is not None and latent_test is not None:
    latent_for_manifold = latent_test if manifold_split == "test" else latent_train
    if manifold_split not in {"train", "test"}:
        raise ValueError("manifold_split must be 'train' or 'test'")

extra_fit = None
# Match `fae_latent_msbm_latent_viz.py`: include knot samples in PCA fit (not full trajectories),
# so the embedding stays consistent with the manifold visualization.
for arr in (latent_f_knots, latent_b_knots):
    if arr is not None:
        flat = arr.reshape(-1, arr.shape[-1])
        extra_fit = flat if extra_fit is None else np.concatenate([extra_fit, flat], axis=0)

if embed_method == "identity" or latent_dim <= embed_dim_eff or latent_for_manifold is None:
    # Identity embedding
    emb = LinearEmbedding(
        mean=np.zeros(latent_dim, dtype=np.float32),
        components=np.eye(latent_dim, dtype=np.float32)[:embed_dim_eff],
    )
    why = []
    if embed_method == "identity":
        why.append("embed_method=identity")
    if latent_dim <= embed_dim_eff:
        why.append(f"latent_dim={latent_dim}<=embed_dim={embed_dim_eff}")
    if latent_for_manifold is None:
        why.append("no manifold background")
    print(f"Using identity embedding ({', '.join(why)})")
else:
    print("Fitting PCA embedding on marginal clouds (+ trajectories)...")
    emb = _fit_pca_embedding(
        latent_for_manifold,
        dim=int(embed_dim_eff),
        max_points=int(max_fit_points),
        seed=int(seed),
        extra=extra_fit,
    )

# Transform trajectories
traj_f_e = emb.transform(latent_f_full) if latent_f_full is not None else None
traj_b_e = emb.transform(latent_b_full) if latent_b_full is not None else None
knots_f_e = emb.transform(latent_f_knots) if latent_f_knots is not None else None
knots_b_e = emb.transform(latent_b_knots) if latent_b_knots is not None else None

print(f"Transformed to {embed_dim_eff}D embedding")

# %% [markdown]
# ## Plot helpers (style consistent with `fae_latent_msbm_latent_viz.py`)

# %%
def _time_colors(times: np.ndarray, cmap_name: str = "viridis", *, vmin: float | None = None, vmax: float | None = None):
    times = np.asarray(times, dtype=np.float32)
    if vmin is None:
        vmin = float(times.min())
    if vmax is None:
        vmax = float(times.max())
    norm = plt.Normalize(vmin=float(vmin), vmax=float(vmax))
    cmap = cm.get_cmap(cmap_name)
    return norm, cmap


def add_start_end_legend(ax, *, loc: str = "best"):
    start_h = Line2D(
        [0],
        [0],
        marker="o",
        linestyle="None",
        markerfacecolor="white",
        markeredgecolor="black",
        markersize=6,
        label="start",
    )
    end_h = Line2D(
        [0],
        [0],
        marker="o",
        linestyle="None",
        markerfacecolor="black",
        markeredgecolor="white",
        markersize=6,
        label="end",
    )
    existing_h, existing_l = ax.get_legend_handles_labels()
    handles = [*existing_h, start_h, end_h]
    labels = [*existing_l, "start", "end"]
    ax.legend(handles=handles, labels=labels, loc=loc)


def plot_manifold_2d(
    latent_e: np.ndarray,  # (T,n,2)
    times: np.ndarray,  # (T,)
    *,
    title: str,
    show_mean_path: bool = True,
    alpha: float = 0.12,
    s: float = 6.0,
    cmap_name: str = "viridis",
):
    norm, cmap = _time_colors(times, cmap_name=cmap_name)
    fig, ax = plt.subplots(figsize=(7, 6))
    for t in range(latent_e.shape[0]):
        c = cmap(norm(float(times[t])))
        ax.scatter(latent_e[t, :, 0], latent_e[t, :, 1], s=s, alpha=alpha, color=c, linewidths=0.0)

    if show_mean_path:
        means = latent_e.mean(axis=1)
        ax.plot(means[:, 0], means[:, 1], color="black", lw=2.0, alpha=0.8, label="marginal mean path")
        ax.scatter(means[:, 0], means[:, 1], color="black", s=25, zorder=3)

    sm = cm.ScalarMappable(norm=norm, cmap=cmap)
    sm.set_array([])
    cb = fig.colorbar(sm, ax=ax, fraction=0.046, pad=0.04)
    cb.set_label("time (zt)", rotation=90)

    ax.set_title(title)
    ax.set_xlabel("PC1" if embed_method == "pca" else "Latent dim 1")
    ax.set_ylabel("PC2" if embed_method == "pca" else "Latent dim 2")
    ax.grid(True, alpha=0.2)
    if show_mean_path:
        ax.legend(loc="best")
    fig.tight_layout()
    return fig, ax


def _infer_steps_per_interval(n_steps_full: int, n_marginals: int) -> int:
    n_intervals = int(n_marginals) - 1
    if n_intervals <= 0:
        raise ValueError("Need at least 2 marginals to infer steps per interval.")
    s_float = 1.0 + (float(n_steps_full) - 1.0) / float(n_intervals)
    s = int(np.round(s_float))
    if abs(s_float - float(s)) > 1e-6 or s < 2:
        raise ValueError(
            f"Could not infer integer steps-per-interval: n_steps_full={n_steps_full}, "
            f"n_marginals={n_marginals}, inferred={s_float}."
        )
    return s


def _build_full_times(zt_marginals: np.ndarray, n_steps_full: int) -> np.ndarray:
    zt_marginals = np.asarray(zt_marginals, dtype=np.float32)
    n_marginals = int(zt_marginals.shape[0])
    s = _infer_steps_per_interval(int(n_steps_full), int(n_marginals))
    parts = []
    for i in range(n_marginals - 1):
        seg = np.linspace(float(zt_marginals[i]), float(zt_marginals[i + 1]), int(s), dtype=np.float32)
        if i > 0:
            seg = seg[1:]
        parts.append(seg)
    out = np.concatenate(parts, axis=0)
    if out.shape[0] != int(n_steps_full):
        raise RuntimeError(f"Internal error: built times have len={out.shape[0]} but expected {n_steps_full}.")
    return out


def plot_full_trajectories_2d(
    ax,
    traj_e: np.ndarray,  # (T_steps,N,2)
    times_full: np.ndarray,  # (T_steps,)
    *,
    n_plot: int,
    reverse: bool = False,
    lw: float = 1.2,
    alpha: float = 0.9,
    cmap_name: str = "viridis",
    zorder: int = 5,
):
    if traj_e is None or traj_e.size == 0:
        return
    if traj_e.shape[-1] != 2:
        raise ValueError("plot_full_trajectories_2d expects 2D embedded trajectories.")
    n_use = min(int(n_plot), int(traj_e.shape[1]))

    times_use = times_full[::-1] if bool(reverse) else times_full
    norm, _cmap = _time_colors(times_use, cmap_name=cmap_name)
    for j in range(n_use):
        pts = traj_e[:, j, :]
        if reverse:
            pts = pts[::-1]
        segs = np.concatenate([pts[:-1, None, :], pts[1:, None, :]], axis=1)
        lc = LineCollection(segs, cmap=cm.get_cmap(cmap_name), norm=norm, linewidths=lw, alpha=alpha, zorder=zorder)
        lc.set_array(times_use[:-1])
        ax.add_collection(lc)
        ax.scatter(
            pts[0, 0],
            pts[0, 1],
            s=26,
            color="white",
            edgecolor="black",
            linewidths=0.9,
            zorder=zorder + 1,
        )
        ax.scatter(
            pts[-1, 0],
            pts[-1, 1],
            s=26,
            color="black",
            edgecolor="white",
            linewidths=0.9,
            zorder=zorder + 1,
        )


def add_time_colorbar(fig, ax, times_full: np.ndarray, *, cmap_name: str = "viridis", label: str = "time (zt)"):
    norm, cmap = _time_colors(times_full, cmap_name=cmap_name)
    sm = cm.ScalarMappable(norm=norm, cmap=cmap)
    sm.set_array([])
    cb = fig.colorbar(sm, ax=ax, fraction=0.046, pad=0.04)
    cb.set_label(label, rotation=90)
    return cb


latent_sub_e = None
if latent_for_manifold is not None:
    latent_sub = _subsample_per_time(latent_for_manifold, points_per_time, seed=seed)
    latent_sub_e = emb.transform(latent_sub)

# %% [markdown]
# ## 2D visualization: Marginal manifold only (no trajectories)
#
# This matches the style of `fae_latent_msbm_latent_viz.py` - showing just the latent manifold.

# %%
if embed_dim_eff != 2:
    print("Set embed_dim=2 for 2D visualization.")
elif latent_sub_e is not None:
    fig, _ax = plot_manifold_2d(
        latent_sub_e,
        zt,
        title=f"FAE latent manifold (PCA) [{manifold_split} split]  |  latent_dim={latent_dim}",
        show_mean_path=True,
    )
    fig.savefig(viz_dir / "latent_manifold_only_2d.png", dpi=150)
    plt.show()
    print(f"Saved: {viz_dir / 'latent_manifold_only_2d.png'}")

# %% [markdown]
# ## 2D visualization: Full SDE trajectories only (no manifold background)
#
# Shows the actual continuous SDE paths without marginal distributions.

# %%
if embed_dim_eff != 2:
    print("Set embed_dim=2 for 2D trajectory visualization.")
else:
    times_f = None
    times_b = None
    if traj_f_e is not None and latent_f_knots is not None:
        times_f = _build_full_times(zt, int(traj_f_e.shape[0]))
    if traj_b_e is not None and latent_b_knots is not None:
        times_b = _build_full_times(zt, int(traj_b_e.shape[0]))

    # Forward trajectories only
    if traj_f_e is not None and times_f is not None:
        fig, ax = plt.subplots(figsize=(8, 7))
        n_use = min(n_traj_plot, traj_f_e.shape[1])
        plot_full_trajectories_2d(ax, traj_f_e, times_f, n_plot=n_traj_plot, lw=1.5, alpha=0.85, zorder=3)
        # add_time_colorbar(fig, ax, times_f, cmap_name="viridis", label="time (zt)")

        # Add marginal knots with a professional marker style (diamond), colored by marginal time.
        if overlay_knots and knots_f_e is not None:
            knot_norm, knot_cmap = _time_colors(zt, cmap_name="viridis")
            for t_idx in range(len(zt)):
                c = knot_cmap(knot_norm(float(zt[t_idx])))
                ax.scatter(
                    knots_f_e[t_idx, :n_use, 0],
                    knots_f_e[t_idx, :n_use, 1],
                    s=42,
                    marker="D",
                    color=c,
                    edgecolor="black",
                    linewidths=0.8,
                    zorder=6,
                )
        add_start_end_legend(ax)

        ax.set_title(f"Full SDE trajectories - Forward policy\n{n_use} samples, {traj_f_e.shape[0]} SDE steps")
        ax.set_xlabel("PC1" if embed_method == "pca" else "Latent dim 1")
        ax.set_ylabel("PC2" if embed_method == "pca" else "Latent dim 2")
        ax.grid(True, alpha=0.3)
        ax.set_aspect('equal', adjustable='box')
        fig.tight_layout()
        fig.savefig(viz_dir / "full_trajectories_forward_only_2d.png", dpi=150)
        plt.show()
        print(f"Saved: {viz_dir / 'full_trajectories_forward_only_2d.png'}")

    # Backward trajectories only
    if traj_b_e is not None and times_b is not None:
        fig, ax = plt.subplots(figsize=(8, 7))
        n_use = min(n_traj_plot, traj_b_e.shape[1])
        # Plot backward in its natural direction (t=1 -> t=0) by reversing the polyline order.
        plot_full_trajectories_2d(
            ax, traj_b_e, times_b, n_plot=n_traj_plot, reverse=True, lw=1.5, alpha=0.85, zorder=3
        )
        # add_time_colorbar(fig, ax, times_b, cmap_name="viridis", label="time (zt)")

        if overlay_knots and knots_b_e is not None:
            knot_norm, knot_cmap = _time_colors(zt, cmap_name="viridis")
            for t_idx in range(len(zt)):
                c = knot_cmap(knot_norm(float(zt[t_idx])))
                ax.scatter(
                    knots_b_e[t_idx, :n_use, 0],
                    knots_b_e[t_idx, :n_use, 1],
                    s=42,
                    marker="D",
                    color=c,
                    edgecolor="black",
                    linewidths=0.8,
                    zorder=6,
                )
        add_start_end_legend(ax)

        ax.set_title(f"Full SDE trajectories - Backward policy\n{n_use} samples, {traj_b_e.shape[0]} SDE steps")
        ax.set_xlabel("PC1" if embed_method == "pca" else "Latent dim 1")
        ax.set_ylabel("PC2" if embed_method == "pca" else "Latent dim 2")
        ax.grid(True, alpha=0.3)
        ax.set_aspect('equal', adjustable='box')
        fig.tight_layout()
        fig.savefig(viz_dir / "full_trajectories_backward_only_2d.png", dpi=150)
        plt.show()
        print(f"Saved: {viz_dir / 'full_trajectories_backward_only_2d.png'}")

# %% [markdown]
# ## 2D visualization: Manifold background + Full trajectories overlay
#
# Combines the marginal distributions with full SDE trajectories.

# %%
if embed_dim_eff != 2:
    print("Set embed_dim=2 for combined visualization.")
elif latent_sub_e is not None:
    times_f = None
    times_b = None
    if traj_f_e is not None and latent_f_knots is not None:
        times_f = _build_full_times(zt, int(traj_f_e.shape[0]))
    if traj_b_e is not None and latent_b_knots is not None:
        times_b = _build_full_times(zt, int(traj_b_e.shape[0]))

    # Forward: manifold + trajectories
    if traj_f_e is not None and times_f is not None:
        fig, ax = plot_manifold_2d(
            latent_sub_e,
            zt,
            title="FAE latent manifold + Full SDE trajectories (forward)",
            show_mean_path=False,
        )
        n_use = min(n_traj_plot, traj_f_e.shape[1])
        plot_full_trajectories_2d(ax, traj_f_e, times_f, n_plot=n_traj_plot, lw=1.8, alpha=0.9, zorder=10)
        # add_time_colorbar(fig, ax, times_f, cmap_name="viridis", label="time (zt)")

        # Overlay marginal knots as distinct markers (exclude endpoints to keep start/end clear)
        if overlay_knots and knots_f_e is not None and len(zt) > 2:
            knot_norm, knot_cmap = _time_colors(zt, cmap_name="viridis")
            for t_idx in range(1, len(zt) - 1):
                c = knot_cmap(knot_norm(float(zt[t_idx])))
                ax.scatter(
                    knots_f_e[t_idx, :n_use, 0],
                    knots_f_e[t_idx, :n_use, 1],
                    s=40,
                    marker="D",
                    color=c,
                    edgecolor="black",
                    linewidths=0.8,
                    zorder=12,
                )
        add_start_end_legend(ax)

        fig.savefig(viz_dir / "manifold_with_trajectories_forward_2d.png", dpi=150)
        plt.show()
        print(f"Saved: {viz_dir / 'manifold_with_trajectories_forward_2d.png'}")

    # Backward: manifold + trajectories
    if traj_b_e is not None and times_b is not None:
        fig, ax = plot_manifold_2d(
            latent_sub_e,
            zt,
            title="FAE latent manifold + Full SDE trajectories (backward)",
            show_mean_path=False,
        )
        n_use = min(n_traj_plot, traj_b_e.shape[1])
        plot_full_trajectories_2d(
            ax, traj_b_e, times_b, n_plot=n_traj_plot, reverse=True, lw=1.8, alpha=0.9, zorder=10
        )
        # add_time_colorbar(fig, ax, times_b, cmap_name="viridis", label="time (zt)")

        if overlay_knots and knots_b_e is not None and len(zt) > 2:
            knot_norm, knot_cmap = _time_colors(zt, cmap_name="viridis")
            for t_idx in range(1, len(zt) - 1):
                c = knot_cmap(knot_norm(float(zt[t_idx])))
                ax.scatter(
                    knots_b_e[t_idx, :n_use, 0],
                    knots_b_e[t_idx, :n_use, 1],
                    s=40,
                    marker="D",
                    color=c,
                    edgecolor="black",
                    linewidths=0.8,
                    zorder=12,
                )
        add_start_end_legend(ax)

        fig.savefig(viz_dir / "manifold_with_trajectories_backward_2d.png", dpi=150)
        plt.show()
        print(f"Saved: {viz_dir / 'manifold_with_trajectories_backward_2d.png'}")
else:
    print("Manifold background not available; showing trajectories only.")

# %% [markdown]
# ## Trajectory Statistics & Analysis

# %%
if latent_f_full is not None and latent_f_knots is not None:
    n_steps_full = latent_f_full.shape[0]
    n_marginals = latent_f_knots.shape[0]
    n_intervals = n_marginals - 1
    steps_per_interval = (n_steps_full - n_marginals + 1) / n_intervals if n_intervals > 0 else 0

    print("=" * 60)
    print("FORWARD TRAJECTORY STATISTICS")
    print("=" * 60)
    print(f"Total SDE steps:        {n_steps_full}")
    print(f"Marginal knots:         {n_marginals}")
    print(f"Intervals:              {n_intervals}")
    print(f"Steps per interval:     {steps_per_interval:.1f}")

    # Compute trajectory metrics
    velocity = np.diff(latent_f_full, axis=0)  # (T-1, N, K)
    speed = np.linalg.norm(velocity, axis=-1)  # (T-1, N)

    print(f"\nSpeed statistics:")
    print(f"  Mean:   {speed.mean():.6f}")
    print(f"  Std:    {speed.std():.6f}")
    print(f"  Min:    {speed.min():.6f}")
    print(f"  Max:    {speed.max():.6f}")

    # Path length
    total_length = speed.sum(axis=0)  # (N,)
    start = latent_f_full[0]
    end = latent_f_full[-1]
    direct_dist = np.linalg.norm(end - start, axis=-1)
    efficiency = total_length / (direct_dist + 1e-8)

    print(f"\nPath efficiency (ratio of path length to direct distance):")
    print(f"  Mean:   {efficiency.mean():.4f}")
    print(f"  Std:    {efficiency.std():.4f}")
    print(f"  (1.0 = straight line, higher = more curved)")

if latent_b_full is not None and latent_b_knots is not None:
    n_steps_full = latent_b_full.shape[0]
    n_marginals = latent_b_knots.shape[0]
    n_intervals = n_marginals - 1
    steps_per_interval = (n_steps_full - n_marginals + 1) / n_intervals if n_intervals > 0 else 0

    print("\n" + "=" * 60)
    print("BACKWARD TRAJECTORY STATISTICS")
    print("=" * 60)
    print(f"Total SDE steps:        {n_steps_full}")
    print(f"Marginal knots:         {n_marginals}")
    print(f"Intervals:              {n_intervals}")
    print(f"Steps per interval:     {steps_per_interval:.1f}")

    velocity = np.diff(latent_b_full, axis=0)
    speed = np.linalg.norm(velocity, axis=-1)

    print(f"\nSpeed statistics:")
    print(f"  Mean:   {speed.mean():.6f}")
    print(f"  Std:    {speed.std():.6f}")
    print(f"  Min:    {speed.min():.6f}")
    print(f"  Max:    {speed.max():.6f}")

    total_length = speed.sum(axis=0)
    start = latent_b_full[0]
    end = latent_b_full[-1]
    direct_dist = np.linalg.norm(end - start, axis=-1)
    efficiency = total_length / (direct_dist + 1e-8)

    print(f"\nPath efficiency:")
    print(f"  Mean:   {efficiency.mean():.4f}")
    print(f"  Std:    {efficiency.std():.4f}")

# %% [markdown]
# ## Summary

# %%
print("\n" + "=" * 60)
print("VISUALIZATION SUMMARY")
print("=" * 60)
print(f"Output directory: {viz_dir}")
print("\nGenerated plots:")
print("  1. latent_manifold_only_2d.png          - FAE latent manifold (marginal distributions)")
print("  2. full_trajectories_forward_only_2d.png - Forward SDE trajectories with knot markers")
print("  3. full_trajectories_backward_only_2d.png - Backward SDE trajectories with knot markers")
print("  4. manifold_with_trajectories_forward_2d.png - Combined manifold + forward trajectories")
print("  5. manifold_with_trajectories_backward_2d.png - Combined manifold + backward trajectories")
print("=" * 60)
